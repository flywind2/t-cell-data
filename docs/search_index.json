[
["microarrays.html", "Chapter 3 Microarrays 3.1 Exploring ImmuneSigDB 3.2 Reproducing a single gene set from ImmuneSigDB", " Chapter 3 Microarrays 3.1 Exploring ImmuneSigDB We need to find T cell data. 3.2 Reproducing a single gene set from ImmuneSigDB Let’s just get the CEL files used to generate the GSE2770_IL12_AND_TGFB_ACT_VS_ACT_CD4_TCELL_6H_DN gene set from ImmuneSigDB (Godec et al. 2016). library(GEOquery) library(oligo) library(limma) library(curl) library(urltools) library(fs) library(lubridate) library(janitor) library(tidyverse) Let’s put all of our downloaded data into a single directory. data_dir &lt;- dir_create(&quot;data&quot;) First, we download data for GSE2770 from GEO. There are 3 elements in this list, 1 for each platform. download_dir &lt;- path(data_dir, &quot;series_matrix_files&quot;) if (!dir_exists(download_dir)) { dir_create(download_dir) GSE2770 &lt;- getGEO(&quot;GSE2770&quot;, getGPL=FALSE, destdir=download_dir) } else { GSE2770 &lt;- dir_ls(download_dir, glob=&quot;*series_matrix*&quot;) %&gt;% purrr::map(~ getGEO(filename=.x, getGPL=FALSE)) } Next, we pull out the phenotype data. pGSE2770 &lt;- GSE2770 %&gt;% purrr::map(~ as(pData(.x), &quot;data.frame&quot;)) %&gt;% bind_rows() %&gt;% as_tibble() Then we tidy up the phenotype data. pGSE2770tidy &lt;- pGSE2770 %&gt;% select(platform_id, geo_accession, supplementary_file, title) %&gt;% separate(title, c(&quot;cells&quot;, &quot;treatment&quot;, &quot;time&quot;, &quot;replicate&quot;, &quot;platform&quot;), sep=&quot;[_\\\\(\\\\)]&quot;) %&gt;% select(-cells) %&gt;% mutate(replicate = map_chr(replicate, ~ str_split(.x, boundary(&quot;word&quot;))[[1]][2])) %&gt;% mutate(time = as.duration(time)) Here we get the CEL file URLs for the two conditions used to generate this particular gene set. # get just the U133A cel files cel_file_urls &lt;- pGSE2770tidy %&gt;% filter(time == duration(&quot;6h&quot;) &amp; (treatment %in% c(&quot;antiCD3+antiCD28+IL12+TGFbeta&quot;, &quot;antiCD3+antiCD28&quot;)) &amp; platform == &quot;U133A&quot;) %&gt;% .$supplementary_file We then download the CEL files. download_dir &lt;- path(data_dir, &quot;cel_files&quot;) if (!dir_exists(download_dir)) { dir_create(download_dir) cel_file_names &lt;- path_file(url_parse(cel_file_urls)$path) cel_files_local &lt;- map2(cel_file_urls, path(download_dir, cel_file_names), ~ curl_download(.x, .y)) %&gt;% simplify() } else { cel_files_local &lt;- dir_ls(download_dir, glob=&quot;*.cel*&quot;, ignore.case=TRUE) } And read them into an oligo ExpressionFeatureSet object. Note the feature data (i.e. the probeset IDs) are not stored in the feature data of the ExpressionSet object, but rather in a SQLlite database pd.hg.u133a somewhere on disk that the call to rma() will pick up. raw_data &lt;- read.celfiles(cel_files_local) Run RMA on our batch of CEL files to be compared. processed_data &lt;- rma(raw_data) as_tibble(exprs(processed_data), rownames = &quot;probe_set_id&quot;) Because we want to do our differential expression analysis at the gene level, not the probeset level, we need to map probeset IDs to gene symbols. To ensure comparability with the GSEA gene sets, we’ll use the annotations provided by the Broad that are used in GSEA. chip_file_url &lt;- &quot;ftp://ftp.broadinstitute.org/pub/gsea/annotations/HG_U133A.chip&quot; chip_file_name &lt;- path_file(url_parse(chip_file_url)$path) download_dir &lt;- path(data_dir, &quot;chip_files&quot;) if (!dir_exists(download_dir)) { dir_create(download_dir) chip_file &lt;- curl_download(chip_file_url, path(download_dir, chip_file_name)) } else { chip_file &lt;- path(download_dir, chip_file_name) } We need to clean up the data a bit: the import produced a bogus column (X4), and we only want one gene symbol per probeset ID. U133A_chip_raw &lt;- read_tsv(chip_file) U133A_chip &lt;- U133A_chip_raw %&gt;% select(-X4) %&gt;% clean_names() %&gt;% rowwise() %&gt;% mutate(first_gene_symbol = str_trim(str_split(gene_symbol, &quot;///&quot;)[[1]][1])) Finally we can join with our processed data! eset_tib &lt;- as_tibble(exprs(processed_data), rownames = &quot;probe_set_id&quot;) eset_tib_genes &lt;- eset_tib %&gt;% left_join(U133A_chip, by = &quot;probe_set_id&quot;) We now remove probesets that don’t map to a gene symbol; note chip files encode this fact with ---, which we demonstrate first before the filter. eset_tib_genes %&gt;% filter(is.na(first_gene_symbol)) %&gt;% count() # 0 eset_tib_genes %&gt;% filter(first_gene_symbol == &quot;---&quot;) %&gt;% count() # 1,109 eset_tib_genes &lt;- eset_tib_genes %&gt;% filter(first_gene_symbol != &quot;---&quot;) Some genes have multiple probesets that map to them. GSEA handles this situation by only keeping the maximum intensity value across all probesets that map to the gene. In GSEA terminology, we are using the max probe algorithm to collapse our pobesets at the gene level. eset_tib_genes_only &lt;- eset_tib_genes %&gt;% select(-c(probe_set_id, gene_symbol, gene_title)) %&gt;% group_by(first_gene_symbol) %&gt;% summarise_all(max) Now we’ll take our new genes-only expression data and put it into a form expected by limma. eset_genes &lt;- eset_tib_genes_only %&gt;% as.data.frame() %&gt;% column_to_rownames(var=&quot;first_gene_symbol&quot;) %&gt;% data.matrix() %&gt;% ExpressionSet() One last step: we need to make the design matrix for this comparison. treatments &lt;- factor(c(1,2,2,1), labels=c(&quot;untreated&quot;, &quot;treated&quot;)) # weird ordering of files design &lt;- model.matrix(~treatments) Finally we use limma to perform a differential expression analysis! fit_genes &lt;- lmFit(eset_genes, design) fit2_genes &lt;- eBayes(fit_genes) results_genes &lt;- topTable(fit2_genes, number=Inf) results_genes_tib &lt;- as_tibble(results_genes, rownames = &quot;gene&quot;) Let’s look at our results. results_genes_tib %&gt;% arrange(desc(logFC)) %&gt;% head(200) %&gt;% arrange(gene) %&gt;% .$gene References "]
]
